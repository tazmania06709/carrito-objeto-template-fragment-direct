//---------------01:08:18---------------curso javascript #02
Objeto literal

Se denomina objeto literal al objeto cuyas propiedades estÔøΩn declaradas textualmente en el cÔøΩdigo.
mas info

const gato = {
    nombre: 'Valiente',
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"]
}

//-----------------------------------Acceder a los valores
NotaciÔøΩn de punto:
js

console.log(gato.nombre)
console.log(gato.duerme)
console.log(gato.enemigos[0]);

NotaciÔøΩn de corchetes (nos servirÔøΩ para recorrerlo):
js

console.log(gato['nombre'])
console.log(gato['edad'])
console.log(gato["enemigos"][0]);
console.log(gato.enemigos[0]);
//-------------------CRUD (propiedades)

------------------Crear (create)
gato.color = 'Azul'

Leer (read)
console.log(gato)

Actualizar (update)
gato.edad = 11

---------------------------Eliminar (delete)
delete gato.duerme

//-----------------hasOwnProperty
A veces es ÔøΩtil comprobar si existe o no la propiedad de un objeto dado. Podemos utilizar el mÔøΩtodo .hasOwnProperty(propname) para determinar si un objeto tiene una propiedad con ese nombre. .hasOwnProperty() devuelve true o false si se encuentra la propiedad o no.
js

const gato = {
    nombre: 'Valiente',
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"]
}

console.log(gato.hasOwnProperty("nombre"))
console.log(gato.hasOwnProperty("salud"))
//-------------------------------Objetos anidados
const gato = {
    nombre: 'Valiente',
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    otros: {
        amigos: ["Cobarde", "TÔøΩmido", "Pegajoso"],
        favoritos: {
            comida: {
                fria: "salmÔøΩn",
                caliente: "pollo"
            }
        }
    }
}

//--------------------------------Acceder:
console.log(gato.otros.amigos[0])
console.log(gato.otros.favoritos.comida.fria)

//---------------Encadenamiento opcional
Optional chaining: El operador de encadenamiento opcional ?. permite leer el valor de una propiedad ubicada dentro de una cadena de objetos conectados sin tener que validar expresamente que cada referencia en la cadena sea vÔøΩlida.

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
};
console.log(gato.otros.favoritos);

-------------------------Encadenamiento opcional: resultado undefined.
console.log(gato.otros?.favoritos);
//-----------Nota: los array tienen propiedades y metodos las primeras no llevan parantesis, las segundas si llevan parentisis y pueden llevar algun parametro.
//---------------Propiedades:
Ejemplo
const frutas = ["sandÔøΩa", "pera", "melon"];
console.log(frutas.length);

-----------------------------MÔøΩtodos:
Ejemplo
const frutas = ["sandÔøΩa", "pera", "melon"];
frutas.push("banana");
console.log(frutas);
//------------------------MÔøΩtodos
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer: function () {
        console.log("Ahora estÔøΩ comiendo");
    },
};

gato.comer();

//---------------------------------Reducido:
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer() {
        console.log("Ahora estÔøΩ comiendo");
    },
};
gato.comer();
------------------Con parÔøΩmetros:
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return "Ahora estÔøΩ comiendo: " + comida;
    },
};
console.log(gato.comer("pez"));
-------------------------ÔøΩQuÔøΩ pasarÔøΩ con esto?
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${nombre} estÔøΩ comiendo ${comida}`;
    },
};
console.log(gato.comer("pez"));

--------------------Lo estÔøΩ buscando en el objeto global
const nombre = "Ignacio";
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${nombre} estÔøΩ comiendo ${comida}`;
    },
};
console.log(gato.comer("pez"));
--------------------------------------Objeto this:
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        console.log(this);
    },
};
gato.comer("pez");

-----------------------------------this
Veamos una introducciÔøΩn a this
this: Hace referencia al objeto contexto de JavaScript en el cual se estÔøΩ ejecutando el cÔøΩdigo actual
mÔøΩs info

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${this.nombre} estÔøΩ comiendo ${comida}`;
    },
};
console.log(gato.comer("pez"));
//-------------------arrow function
--------------------ÔøΩEsto funcionarÔøΩ?
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer: (comida) => {
        return `${this.nombre} estÔøΩ comiendo ${comida}`;
    },
};

console.log(gato.comer("pez"));

----------------------------Arrow Functions
No tiene this o super y no se debe usarla como mÔøΩtodos.
//---------------------Pero si puedo utilizarla en su interior:
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${this.nombre} estÔøΩ comiendo ${comida}`;
    },
    mostrarEnemigos() {
        return this.enemigos.forEach((item) => console.log(item));
    },
};

gato.mostrarEnemigos();
//------------------------------Recorrer un objeto
for in

for...in

    for in: La instrucciÔøΩn for-in itera sobre todas las propiedades enumerables de un objeto que estÔøΩ codificado por cadenas

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
};

for (const propiedad in gato) {
    console.log(gato[propiedad]);
}

---------------------------ÔøΩPor quÔøΩ usar for...in?
Dado que for...in estÔøΩ construido para iterar propiedades de objeto, no se recomienda su uso con arreglos y opciones como Array.prototype.forEach() y existe for...of, ÔøΩcuÔøΩl podrÔøΩa ser el uso de for...in?
Es posible que se utilice de forma mÔøΩs prÔøΩctica con fines de depuraciÔøΩn, ya que es una forma fÔøΩcil de comprobar las propiedades de un objeto (mediante la salida a la consola o de otro modo)
Aunque los arreglos suelen ser mÔøΩs prÔøΩcticos para almacenar datos, en situaciones en las que se prefiere un par clave-valor para trabajar con datos (con propiedades que actÔøΩan como la "clave"), puede haber casos en los que desees comprobar si alguna de esas claves cumple un valor particular.
//--------------------Object.values()
Object.values(): devuelve un array con los valores correspondientes a las propiedades enumerables de un objeto.

console.log(Object.values(gato));

Con forEach()

Object.values(gato).forEach((item) => console.log(item));

------------------Existen mÔøΩs mÔøΩtodos como:
Object.entries()
Object.key()
Object.getOwnPropertyNames()
//--------------------------------------Destructuring Objects
desestructuraciÔøΩn La sintaxis de desestructuraciÔøΩn es una expresiÔøΩn de JavaScript que permite desempacar valores de arreglos o propiedades de objetos en distintas variables.

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    otros: {
        amigos: ["Cobarde", "TÔøΩmido", "Pegajoso"],
        favoritos: {
            comida: {
                fria: "salmÔøΩn",
                caliente: "pollo",
            },
        },
    },
};

const nombreGato = gato.nombre;
console.log(nombreGato);

------------------------------------Destructuring de objetos:

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    otros: {
        amigos: ["Cobarde", "TÔøΩmido", "Pegajoso"],
        favoritos: {
            comida: {
                fria: "salmÔøΩn",
                caliente: "pollo",
            },
        },
    },
};

const { nombre, duerme, edad, enemigos } = gato;
console.log(nombre);
console.log(duerme);
console.log(edad);
console.log(enemigos);

--------------------------------Alias:

const { nombre: nombreGato } = gato;
console.log(nombreGato);

--------------------por defecto:

const gato = {
    // nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    otros: {
        amigos: ["Cobarde", "TÔøΩmido", "Pegajoso"],
        favoritos: {
            comida: {
                fria: "salmÔøΩn",
                caliente: "pollo",
            },
        },
    },
};

const { nombre: nombreGato = "Sin nombre" } = gato;
console.log(nombreGato);

----------------------Anidados:

const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    otros: {
        amigos: ["Cobarde", "TÔøΩmido", "Pegajoso"],
        favoritos: {
            comida: {
                fria: "salmÔøΩn",
                caliente: "pollo",
            },
        },
    },
};

const {
    otros: { amigos },
} = gato;
console.log(amigos);

//---------------------------------------------Array

La destructuring tambiÔøΩn sirve para Array, solo reemplazar por []

//-------------Array destructuracion
const enemigos = ["agua", "perros"]
const [agua, perro] = enemigos;
console.log(agua);
console.log(perro);
// const enemigos = ["agua", "perros"];
// const [pos1, pos2] = enemigos;
// console.log(pos1,pos2);

-------------------------MÔøΩtodos:
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${this.nombre} estÔøΩ comiendo ${comida}`;
    },
    mostrarEnemigos() {
        return this.enemigos.forEach((item) => console.log(item));
    },
};

const { comer } = gato;
console.log(comer("pez"));

// undefined estÔøΩ comiendo pez
Nota: porque no se puede destructurar una metodo que dentro tenga this.....
const  comer = gato.comer('pez');
console.log(comer);
//---------------------------Getters y Setters
info
get: Enlaza la propiedad de un objeto con una funciÔøΩn que serÔøΩ llamada cuando la propiedad es buscada.
set: La sintaxis set asocia la propiedad de un objeto a una funciÔøΩn que serÔøΩ llamada cuando haya un intento de asignar valor a esa propiedad.

GET: Tenga en cuenta lo siguiente al trabajar con la sintaxis get:

    Debe tener exactamente cero parametros.
    No debe haber mÔøΩltiples getters para una misma propiedad.

SET: Tenga en cuenta lo siguiente al trabajar con setters:

    Debe tener exactamente un parÔøΩmentro

-------------------------------------------------
const gato = {
    nombre: "Valiente",
    duerme: true,
    edad: 10,
    enemigos: ["agua", "perros"],
    comer(comida) {
        return `${this.nombre} estÔøΩ comiendo ${comida}`;
    },
    get nombreMayuscula() {
        return this.nombre.toUpperCase();
    },
    set nuevoEnemigo(nuevo) {
        this.enemigos.push(nuevo);
    },
};

//---------------------- GET
console.log(gato.nombreMayuscula);

//--------------------------- SET
gato.nuevoEnemigo = "batman";
console.log(gato.enemigos);

por valor vs por referencia
  fuente
    por valor: Cuando asignamos valores primitivos (Boolean, Null, Undefined, Number, String y Symbol), el valor asignado es una copia del valor que estamos asignando.
    por referencia: Pero cuando asignamos valores NO primitivos o complejos (Object, Array y Function), JavaScript copia ÔøΩla referenciaÔøΩ, lo que implica que no se copia el valor en sÔøΩ, si no una referencia a travÔøΩs de la cual accedemos al valor original.

--------------------------------Primitivos: (por valor)

let a = "hola";
let b = a;
console.log(b);

Si cambiamos el valor de a, b sigue siendo "hola"
js

a = "chao";
console.log(b);

-----------------No primitivos: (por referencia)
js

let a = ["hola"];
let b = a;
console.log(b);

js

let a = ["hola"];
let b = a;

a.push("chao");

console.log(b);

------------------------------Lo mismo pasa con los objetos:
js

const a = {
    nombre: "hola",
};

const b = a;

a.nombre = "chao";

console.log(b);


//--------------------------------------------------VIDEO TIME 02:24:00----------------------------------

console.log( "üòçüòçüòçü§£üòú");
// console.log(document);


// console.log(document.head);
// console.log(document.title);
// console.log(document.body);
// console.log(document.domain);



// const gato = {
//     nombre: "Valiente",
//     duerme: true,
//     edad: 10,
//     enemigos: ["agua", "perros"],
//     comer(comida) {
//         return `${this.nombre} est√° comiendo ${comida}`;
//     },
//     mostrarEnemigos() {
//         return this.enemigos.forEach((item) => console.log(item));
//     },
// };

// const  comer = gato.comer('pez');
// console.log(comer);

// undefined est√° comiendo pez